<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RUBIK'S DITHER</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Fragment+Mono:ital@0;1&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    body {
      background: #000;
      color: #fff;
      font-family: 'Fragment Mono', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    .title {
      position: fixed;
      top: 2rem;
      left: 2rem;
      font-size: 0.75rem;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      opacity: 0.6;
    }

    @media (max-width: 767px) {
      .title {
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
      }
    }

    .info {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      font-size: 0.65rem;
      text-align: right;
      opacity: 0.4;
      line-height: 1.8;
    }

    .move {
      position: fixed;
      bottom: 2rem;
      left: 2rem;
      font-size: 0.65rem;
      font-variant-numeric: tabular-nums;
      opacity: 0.4;
    }

    .bio {
      position: fixed;
      top: 50%;
      right: 15%;
      transform: translateY(-100%);
      max-width: 300px;
      font-size: 0.9rem;
      line-height: 1.6;
      opacity: 0.8;
      margin-bottom: 2rem;
    }

    .buttons {
      position: fixed;
      top: 50%;
      right: 15%;
      transform: translateY(20%);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .btn {
      position: relative;
      display: inline-block;
      padding: 0.75rem 2rem;
      font-family: 'Fragment Mono', monospace;
      font-size: 0.8rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: #fff;
      background: #000;
      border: 1px solid #fff;
      text-decoration: none;
      cursor: pointer;
      transition: transform 0.1s ease;
    }

    .btn::after {
      content: '';
      position: absolute;
      top: 4px;
      left: 4px;
      right: -4px;
      bottom: -4px;
      background-image: url("data:image/svg+xml,%3Csvg width='4' height='4' viewBox='0 0 4 4' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='0' y='0' width='1' height='1' fill='white'/%3E%3Crect x='2' y='2' width='1' height='1' fill='white'/%3E%3C/svg%3E");
      background-repeat: repeat;
      z-index: -1;
      pointer-events: none;
    }

    .btn:hover {
      transform: translate(2px, 2px);
    }

    .btn:hover::after {
      top: 2px;
      left: 2px;
      right: -2px;
      bottom: -2px;
    }

    @media (max-width: 767px) {
      .bio {
        top: auto;
        bottom: 22%;
        right: auto;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        max-width: 280px;
        font-size: 0.8rem;
      }

      .buttons {
        top: auto;
        bottom: 10%;
        right: 50%;
        transform: translateX(50%);
        flex-direction: row;
        gap: 1rem;
      }

      .btn {
        padding: 0.6rem 1.5rem;
        font-size: 0.7rem;
      }
    }
  </style>
</head>
<body>
  <div class="title">Palash Taneja</div>
  <canvas id="canvas"></canvas>
  <div class="bio">
    Hey, I'm Palash, and I'm a software engineer based out of Brooklyn, NY.
  </div>
  <div class="buttons">
    <a href="blog/index.html" class="btn">Blog</a>
    <a href="#" class="btn">Resume</a>
  </div>
  <div class="move" id="move">Move: —</div>
  <div class="info">
    3×3×3 Cube<br>
    Layer Rotation
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const moveEl = document.getElementById('move');

    // Bayer 8x8 dithering matrix
    const bayerMatrix = [
      [ 0, 32,  8, 40,  2, 34, 10, 42],
      [48, 16, 56, 24, 50, 18, 58, 26],
      [12, 44,  4, 36, 14, 46,  6, 38],
      [60, 28, 52, 20, 62, 30, 54, 22],
      [ 3, 35, 11, 43,  1, 33,  9, 41],
      [51, 19, 59, 27, 49, 17, 57, 25],
      [15, 47,  7, 39, 13, 45,  5, 37],
      [63, 31, 55, 23, 61, 29, 53, 21]
    ];

    const bayerNorm = bayerMatrix.map(row => row.map(v => v / 64));

    let width, height, pixelSize;

    // Fixed viewing angle
    const viewRotX = 0.5;
    const viewRotY = -0.6;

    // Rubik's cube colors (grayscale values for dithering)
    const faceColors = [
      { gray: 1.0 },    // White (front, z=-1)
      { gray: 0.85 },   // Yellow (back, z=1)
      { gray: 0.25 },   // Red (left, x=-1)
      { gray: 0.50 },   // Orange (right, x=1)
      { gray: 0.30 },   // Blue (bottom, y=-1)
      { gray: 0.45 }    // Green (top, y=1)
    ];

    // Move definitions: axis, layer (-1, 0, 1), direction (1 or -1)
    const moves = [
      { name: "R", axis: 'x', layer: 1, dir: 1 },
      { name: "R'", axis: 'x', layer: 1, dir: -1 },
      { name: "L", axis: 'x', layer: -1, dir: -1 },
      { name: "L'", axis: 'x', layer: -1, dir: 1 },
      { name: "U", axis: 'y', layer: 1, dir: 1 },
      { name: "U'", axis: 'y', layer: 1, dir: -1 },
      { name: "D", axis: 'y', layer: -1, dir: -1 },
      { name: "D'", axis: 'y', layer: -1, dir: 1 },
      { name: "F", axis: 'z', layer: -1, dir: 1 },
      { name: "F'", axis: 'z', layer: -1, dir: -1 },
      { name: "B", axis: 'z', layer: 1, dir: -1 },
      { name: "B'", axis: 'z', layer: 1, dir: 1 },
    ];

    // Current animation state
    let currentMove = null;
    let moveAngle = 0;
    let moveQueue = [];
    let pauseTimer = 0;

    function resize() {
      const minDim = Math.min(window.innerWidth, window.innerHeight);
      pixelSize = Math.max(2, Math.floor(minDim / 220));
      width = Math.floor(window.innerWidth / pixelSize);
      height = Math.floor(window.innerHeight / pixelSize);
      canvas.width = width;
      canvas.height = height;
      canvas.style.width = width * pixelSize + 'px';
      canvas.style.height = height * pixelSize + 'px';
    }

    resize();
    window.addEventListener('resize', resize);

    // 3D math
    function rotateX(p, a) {
      const cos = Math.cos(a), sin = Math.sin(a);
      return [p[0], p[1] * cos - p[2] * sin, p[1] * sin + p[2] * cos];
    }

    function rotateY(p, a) {
      const cos = Math.cos(a), sin = Math.sin(a);
      return [p[0] * cos + p[2] * sin, p[1], -p[0] * sin + p[2] * cos];
    }

    function rotateZ(p, a) {
      const cos = Math.cos(a), sin = Math.sin(a);
      return [p[0] * cos - p[1] * sin, p[0] * sin + p[1] * cos, p[2]];
    }

    function project(p, scale, offsetX, offsetY) {
      const fov = 120;
      const z = p[2] + 14;
      const factor = fov / z;
      return [
        p[0] * factor * scale + offsetX,
        p[1] * factor * scale + offsetY,
        z
      ];
    }

    // Cubie state - stores position and face colors
    let cubieState = [];

    function initCubies() {
      cubieState = [];
      const gap = 0.08;
      const size = 0.6;

      for (let x = -1; x <= 1; x++) {
        for (let y = -1; y <= 1; y++) {
          for (let z = -1; z <= 1; z++) {
            if (x === 0 && y === 0 && z === 0) continue;

            // Face colors based on original position
            const faceColorIndices = [
              z === -1 ? 0 : -1,  // front (white)
              z === 1 ? 1 : -1,   // back (yellow)
              x === -1 ? 2 : -1,  // left (red)
              x === 1 ? 3 : -1,   // right (orange)
              y === -1 ? 4 : -1,  // bottom (blue)
              y === 1 ? 5 : -1    // top (green)
            ];

            cubieState.push({
              pos: [x, y, z],
              faceColors: faceColorIndices,
              size,
              gap
            });
          }
        }
      }
    }

    initCubies();

    function getCubieVerts(cubie) {
      const { pos, size, gap } = cubie;
      const cx = pos[0] * (size + gap);
      const cy = pos[1] * (size + gap);
      const cz = pos[2] * (size + gap);
      const hs = size / 2;

      return [
        [cx - hs, cy - hs, cz - hs],
        [cx + hs, cy - hs, cz - hs],
        [cx + hs, cy + hs, cz - hs],
        [cx - hs, cy + hs, cz - hs],
        [cx - hs, cy - hs, cz + hs],
        [cx + hs, cy - hs, cz + hs],
        [cx + hs, cy + hs, cz + hs],
        [cx - hs, cy + hs, cz + hs]
      ];
    }

    const faceIndices = [
      [0, 1, 2, 3], // front
      [5, 4, 7, 6], // back
      [4, 0, 3, 7], // left
      [1, 5, 6, 2], // right
      [4, 5, 1, 0], // bottom
      [3, 2, 6, 7]  // top
    ];

    function rotateLayer(axis, layer, angle) {
      // Rotate vertices of cubies in the specified layer
      const rotatedCubies = [];

      for (const cubie of cubieState) {
        let verts = getCubieVerts(cubie);
        const axisIdx = axis === 'x' ? 0 : (axis === 'y' ? 1 : 2);

        // Check if this cubie is in the rotating layer
        if (cubie.pos[axisIdx] === layer) {
          // Apply layer rotation to vertices
          verts = verts.map(v => {
            if (axis === 'x') return rotateX(v, angle);
            if (axis === 'y') return rotateY(v, angle);
            return rotateZ(v, angle);
          });
        }

        rotatedCubies.push({
          verts,
          faceColors: cubie.faceColors,
          inLayer: cubie.pos[axisIdx] === layer
        });
      }

      return rotatedCubies;
    }

    function applyMove(move) {
      // Update cubie positions and face colors after a 90° rotation
      const { axis, layer, dir } = move;
      const axisIdx = axis === 'x' ? 0 : (axis === 'y' ? 1 : 2);

      for (const cubie of cubieState) {
        if (cubie.pos[axisIdx] !== layer) continue;

        // Rotate position
        const [x, y, z] = cubie.pos;
        if (axis === 'x') {
          cubie.pos = [x, -z * dir, y * dir];
        } else if (axis === 'y') {
          cubie.pos = [z * dir, y, -x * dir];
        } else {
          cubie.pos = [-y * dir, x * dir, z];
        }

        // Rotate face colors
        const fc = cubie.faceColors;
        if (axis === 'x') {
          // Rotate around X: front<->top<->back<->bottom
          if (dir === 1) {
            cubie.faceColors = [fc[4], fc[5], fc[2], fc[3], fc[1], fc[0]];
          } else {
            cubie.faceColors = [fc[5], fc[4], fc[2], fc[3], fc[0], fc[1]];
          }
        } else if (axis === 'y') {
          // Rotate around Y: front<->left<->back<->right
          if (dir === 1) {
            cubie.faceColors = [fc[3], fc[2], fc[0], fc[1], fc[4], fc[5]];
          } else {
            cubie.faceColors = [fc[2], fc[3], fc[1], fc[0], fc[4], fc[5]];
          }
        } else {
          // Rotate around Z: top<->right<->bottom<->left
          if (dir === 1) {
            cubie.faceColors = [fc[0], fc[1], fc[4], fc[5], fc[3], fc[2]];
          } else {
            cubie.faceColors = [fc[0], fc[1], fc[5], fc[4], fc[2], fc[3]];
          }
        }
      }
    }

    function queueRandomMove() {
      const move = moves[Math.floor(Math.random() * moves.length)];
      moveQueue.push(move);
    }

    function getFaceInfo(verts, indices) {
      const v0 = verts[indices[0]];
      const v1 = verts[indices[1]];
      const v2 = verts[indices[2]];

      const ax = v1[0] - v0[0], ay = v1[1] - v0[1], az = v1[2] - v0[2];
      const bx = v2[0] - v0[0], by = v2[1] - v0[1], bz = v2[2] - v0[2];

      const nx = ay * bz - az * by;
      const ny = az * bx - ax * bz;
      const nz = ax * by - ay * bx;

      const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
      const normal = [nx / len, ny / len, nz / len];

      // Light coming from the left side (-x direction)
      const light = [-1, 0, 0];

      const dot = normal[0] * light[0] + normal[1] * light[1] + normal[2] * light[2];

      const centerZ = (v0[2] + v1[2] + verts[indices[2]][2] + verts[indices[3]][2]) / 4;

      // Harsh lighting: bright if facing light, dark otherwise
      const brightness = dot > 0 ? 0.9 : 0.15;
      return { normal, brightness, centerZ };
    }

    function dither(x, y, value) {
      const threshold = bayerNorm[y % 8][x % 8];
      return value > threshold ? 1 : 0;
    }

    function sign(p1x, p1y, p2x, p2y, p3x, p3y) {
      return (p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y);
    }

    function pointInTriangle(px, py, v1, v2, v3) {
      const d1 = sign(px, py, v1[0], v1[1], v2[0], v2[1]);
      const d2 = sign(px, py, v2[0], v2[1], v3[0], v3[1]);
      const d3 = sign(px, py, v3[0], v3[1], v1[0], v1[1]);

      const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
      const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);

      return !(hasNeg && hasPos);
    }

    function drawLine(p0, p1, imageData) {
      // Bresenham's line algorithm
      let x0 = Math.round(p0[0]);
      let y0 = Math.round(p0[1]);
      const x1 = Math.round(p1[0]);
      const y1 = Math.round(p1[1]);

      const dx = Math.abs(x1 - x0);
      const dy = Math.abs(y1 - y0);
      const sx = x0 < x1 ? 1 : -1;
      const sy = y0 < y1 ? 1 : -1;
      let err = dx - dy;

      while (true) {
        if (x0 >= 0 && x0 < width && y0 >= 0 && y0 < height) {
          const idx = (y0 * width + x0) * 4;
          imageData.data[idx] = 255;
          imageData.data[idx + 1] = 255;
          imageData.data[idx + 2] = 255;
          imageData.data[idx + 3] = 255;
        }

        if (x0 === x1 && y0 === y1) break;
        const e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x0 += sx; }
        if (e2 < dx) { err += dx; y0 += sy; }
      }
    }

    function fillTriangle(p0, p1, p2, brightness, colorIdx, imageData) {
      const minX = Math.max(0, Math.floor(Math.min(p0[0], p1[0], p2[0])));
      const maxX = Math.min(width - 1, Math.ceil(Math.max(p0[0], p1[0], p2[0])));
      const minY = Math.max(0, Math.floor(Math.min(p0[1], p1[1], p2[1])));
      const maxY = Math.min(height - 1, Math.ceil(Math.max(p0[1], p1[1], p2[1])));

      if (colorIdx === -1) {
        for (let y = minY; y <= maxY; y++) {
          for (let x = minX; x <= maxX; x++) {
            if (pointInTriangle(x, y, p0, p1, p2)) {
              const idx = (y * width + x) * 4;
              const val = dither(x, y, brightness * 0.15) * 40;
              imageData.data[idx] = val;
              imageData.data[idx + 1] = val;
              imageData.data[idx + 2] = val;
              imageData.data[idx + 3] = 255;
            }
          }
        }
        return;
      }

      const color = faceColors[colorIdx];

      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          if (pointInTriangle(x, y, p0, p1, p2)) {
            const idx = (y * width + x) * 4;
            const litGray = color.gray * brightness;

            if (dither(x, y, litGray)) {
              imageData.data[idx] = 255;
              imageData.data[idx + 1] = 255;
              imageData.data[idx + 2] = 255;
            } else {
              imageData.data[idx] = 0;
              imageData.data[idx + 1] = 0;
              imageData.data[idx + 2] = 0;
            }
            imageData.data[idx + 3] = 255;
          }
        }
      }
    }

    function render() {
      const imageData = ctx.createImageData(width, height);

      // Clear to black
      for (let i = 0; i < imageData.data.length; i += 4) {
        imageData.data[i] = 0;
        imageData.data[i + 1] = 0;
        imageData.data[i + 2] = 0;
        imageData.data[i + 3] = 255;
      }

      // Handle move animation
      if (pauseTimer > 0) {
        pauseTimer--;
      } else if (currentMove) {
        moveAngle += 0.08 * currentMove.dir;
        const targetAngle = (Math.PI / 2) * currentMove.dir;

        if (Math.abs(moveAngle) >= Math.abs(targetAngle)) {
          applyMove(currentMove);
          currentMove = null;
          moveAngle = 0;
          pauseTimer = 30; // Brief pause between moves
          moveEl.textContent = 'Move: —';
        }
      } else if (moveQueue.length > 0) {
        currentMove = moveQueue.shift();
        moveEl.textContent = `Move: ${currentMove.name}`;
      } else {
        queueRandomMove();
      }

      // Get cubies with layer rotation applied
      let rotatedCubies;
      if (currentMove) {
        rotatedCubies = rotateLayer(currentMove.axis, currentMove.layer, moveAngle);
      } else {
        rotatedCubies = cubieState.map(c => ({
          verts: getCubieVerts(c),
          faceColors: c.faceColors,
          inLayer: false
        }));
      }

      // Scale to fit - half the previous size
      const scale = Math.min(width, height) * 0.015;

      // Position: left side on desktop, top center (below title) on mobile
      const isMobile = window.innerWidth < 768;
      const cubeX = isMobile ? width / 2 : width * 0.25;
      const cubeY = isMobile ? height * 0.4 : height / 2;

      const allFaces = [];

      for (const cubie of rotatedCubies) {
        // Apply view rotation
        const transformed = cubie.verts.map(v => {
          let p = rotateX(v, viewRotX);
          p = rotateY(p, viewRotY);
          return p;
        });

        const projected = transformed.map(v => project(v, scale, cubeX, cubeY));

        for (let i = 0; i < 6; i++) {
          const info = getFaceInfo(transformed, faceIndices[i]);
          if (info.normal[2] >= 0) continue;

          allFaces.push({
            projected,
            indices: faceIndices[i],
            colorIdx: cubie.faceColors[i],
            brightness: info.brightness,
            centerZ: info.centerZ
          });
        }
      }

      allFaces.sort((a, b) => b.centerZ - a.centerZ);

      for (const face of allFaces) {
        const p0 = face.projected[face.indices[0]];
        const p1 = face.projected[face.indices[1]];
        const p2 = face.projected[face.indices[2]];
        const p3 = face.projected[face.indices[3]];

        fillTriangle(p0, p1, p2, face.brightness, face.colorIdx, imageData);
        fillTriangle(p0, p2, p3, face.brightness, face.colorIdx, imageData);

        // Draw white edges
        drawLine(p0, p1, imageData);
        drawLine(p1, p2, imageData);
        drawLine(p2, p3, imageData);
        drawLine(p3, p0, imageData);
      }

      // Draw external cube edges (the outer bounding box of the whole Rubik's cube)
      const cubeSize = 3 * (0.6 + 0.08) / 2; // 3 cubies * (size + gap) / 2
      const outerVerts = [
        [-cubeSize, -cubeSize, -cubeSize],
        [cubeSize, -cubeSize, -cubeSize],
        [cubeSize, cubeSize, -cubeSize],
        [-cubeSize, cubeSize, -cubeSize],
        [-cubeSize, -cubeSize, cubeSize],
        [cubeSize, -cubeSize, cubeSize],
        [cubeSize, cubeSize, cubeSize],
        [-cubeSize, cubeSize, cubeSize]
      ];

      // Apply any current layer rotation won't affect the outer box, just view rotation
      const outerTransformed = outerVerts.map(v => {
        let p = rotateX(v, viewRotX);
        p = rotateY(p, viewRotY);
        return p;
      });

      const outerProjected = outerTransformed.map(v => project(v, scale, cubeX, cubeY));

      // Draw all 12 edges of the outer cube
      const outerEdges = [
        [0, 1], [1, 2], [2, 3], [3, 0], // front face
        [4, 5], [5, 6], [6, 7], [7, 4], // back face
        [0, 4], [1, 5], [2, 6], [3, 7]  // connecting edges
      ];

      for (const [i, j] of outerEdges) {
        drawLine(outerProjected[i], outerProjected[j], imageData);
      }

      ctx.putImageData(imageData, 0, 0);
      requestAnimationFrame(render);
    }

    render();
  </script>
</body>
</html>
